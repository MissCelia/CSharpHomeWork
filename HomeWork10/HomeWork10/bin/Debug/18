<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="引言 之前的一篇介绍IO 模型的文章 &amp;quot;IO 模型知多少 | 理论篇&amp;quot; 比较偏理论，很多同学反应不是很好理解。这一篇咱们换一个角度，从代码角度来分析一下。 socket 编程基础 " />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>IO 模型知多少 | 代码篇 - 「圣杰」 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=KCO3_f2W_TC__-jZ7phSnmoFkQuWMJH2yAgA16eE3eY" />
    <link id="MainCss" rel="stylesheet" href="/skins/simplememory/bundle-simplememory.min.css?v=OL4qeo1LNGlN1rKIhv5UctANvt0M6Nx6kLzr_ffx3Xk" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/sheng-jie/custom.css?v=s4FAI3ccmMay6&#x2B;3048NfU3gf3oc=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/SimpleMemory/bundle-SimpleMemory-mobile.min.css" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/sheng-jie/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/sheng-jie/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/sheng-jie/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=ADZDggF2NY5PM0ARXcJqg_CWlG3B72Ho5xCyukyKFbg"></script>
    <script>
        var currentBlogId = 326932;
        var currentBlogApp = 'sheng-jie';
        var cb_enable_mathjax = true;
        var isLogined = false;
        var skinName = 'SimpleMemory';
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;v=20200504"></script>
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <a href="https://github.com/sheng-jie"  target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="100" height="100" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

<style>
#home{
width:85%
}
#back-top {
     position: fixed;
     bottom: 10px;
     right: 5px;
     z-index: 99;
}
#back-top span {
     width: 50px;
     height: 64px;
     display: block;
     background:url(http://images.cnblogs.com/cnblogs_com/seanshao/855033/o_rocket.png) no-repeat center center;
}
#back-top a{outline:none}
</style>
    </div>
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/sheng-jie/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/sheng-jie/">『___知多少』</a>
</h1>
<h2>
一名立志成为架构师并为之努力奋斗的程序员！
</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/sheng-jie/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E3%80%8C%E5%9C%A3%E6%9D%B0%E3%80%8D">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/sheng-jie/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
128&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
983</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-the-io-models-demo.html">IO 模型知多少 | 代码篇</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <h1 id="引言">引言</h1>
<p>之前的一篇介绍IO 模型的文章<a href="https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html">IO 模型知多少 | 理论篇</a><br>
比较偏理论，很多同学反应不是很好理解。这一篇咱们换一个角度，从代码角度来分析一下。</p>
<h1 id="socket-编程基础">socket 编程基础</h1>
<p>开始之前，我们先来梳理一下，需要提前了解的几个概念：</p>
<blockquote>
<p>socket: 直译为“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。我们把插头插到插座上就能从电网获得电力供应，同样，应用程序为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。</p>
</blockquote>
<p>另外还需要知道的是，socket 编程的基本流程。<br>
<img src="https://upload-images.jianshu.io/upload_images/2799767-5f95e14aac563bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket 编程流程"></p>
<h1 id="同步阻塞io">同步阻塞IO</h1>
<p>先回顾下概念：阻塞IO是指，应用进程中线程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。</p>
<pre><code>public static void Start()
{
    //1. 创建Tcp Socket对象
    var serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    var ipEndpoint = new IPEndPoint(IPAddress.Loopback, 5001);
    //2. 绑定Ip端口
    serverSocket.Bind(ipEndpoint);
    //3. 开启监听，指定最大连接数
    serverSocket.Listen(10);
    Console.WriteLine($&quot;服务端已启动({ipEndpoint})-等待连接...&quot;);

    while (true)
    {
        //4. 等待客户端连接
        var clientSocket = serverSocket.Accept();//阻塞
        Console.WriteLine($&quot;{clientSocket.RemoteEndPoint}-已连接&quot;);
        Span&lt;byte&gt; buffer = new Span&lt;byte&gt;(new byte[512]);
        Console.WriteLine($&quot;{clientSocket.RemoteEndPoint}-开始接收数据...&quot;);
        int readLength = clientSocket.Receive(buffer);//阻塞
        var msg = Encoding.UTF8.GetString(buffer.ToArray(), 0, readLength);
        Console.WriteLine($&quot;{clientSocket.RemoteEndPoint}-接收数据：{msg}&quot;);
        var sendBuffer = Encoding.UTF8.GetBytes($&quot;received:{msg}&quot;);
        clientSocket.Send(sendBuffer);
    }
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/2799767-c4034c0af2e3b32f.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>代码很简单，直接看注释就OK了，运行结果如上图所示，但有几个问题点需要着重说明下：</p>
<ol>
<li>等待连接处<code>serverSocket.Accept()</code>，线程阻塞！</li>
<li>接收数据处<code>clientSocket.Receive(buffer)</code>，线程阻塞！</li>
</ol>
<p>会导致什么问题呢：</p>
<ol>
<li>只有一次数据读取完成后，才可以接受下一个连接请求</li>
<li>一个连接，只能接收一次数据</li>
</ol>
<h1 id="同步非阻塞io">同步非阻塞IO</h1>
<p>看完，你可能会说，这两个问题很好解决啊，创建一个新线程去接收数据就是了。于是就有了下面的代码改进。</p>
<pre><code>public static void Start2()
{
    //1. 创建Tcp Socket对象
    var serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    var ipEndpoint = new IPEndPoint(IPAddress.Loopback, 5001);
    //2. 绑定Ip端口
    serverSocket.Bind(ipEndpoint);
    //3. 开启监听，指定最大连接数
    serverSocket.Listen(10);
    Console.WriteLine($&quot;服务端已启动({ipEndpoint})-等待连接...&quot;);

    while (true)
    {
        //4. 等待客户端连接
        var clientSocket = serverSocket.Accept();//阻塞
        Task.Run(() =&gt; ReceiveData(clientSocket));
    }
}

private static void ReceiveData(Socket clientSocket)
{
    Console.WriteLine($&quot;{clientSocket.RemoteEndPoint}-已连接&quot;);
    Span&lt;byte&gt; buffer = new Span&lt;byte&gt;(new byte[512]);

    while (true)
    {
        if (clientSocket.Available == 0) continue;
        Console.WriteLine($&quot;{clientSocket.RemoteEndPoint}-开始接收数据...&quot;);
        int readLength = clientSocket.Receive(buffer);//阻塞
        var msg = Encoding.UTF8.GetString(buffer.ToArray(), 0, readLength);
        Console.WriteLine($&quot;{clientSocket.RemoteEndPoint}-接收数据：{msg}&quot;);
        var sendBuffer = Encoding.UTF8.GetBytes($&quot;received:{msg}&quot;);
        clientSocket.Send(sendBuffer);
    }
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/2799767-12046ce197b2f2b3.gif?imageMogr2/auto-orient/strip" alt="多线程"></p>
<p>是的，多线程解决了上述的问题，但如果你观察以上动图后，你应该能发现个问题：<strong>才建立4个客户端连接，CPU的占用率就开始直线上升了。</strong></p>
<p>而这个问题的本质就是，服务端的IO模型为阻塞IO模型，为了解决阻塞导致的问题，采用重复轮询，导致无效的系统调用，从而导致CPU持续走高。</p>
<h1 id="io多路复用">IO多路复用</h1>
<p>既然知道原因所在，咱们就来予以改造。适用异步方式来处理连接、接收和发送数据。</p>
<pre><code>public static class NioServer
{
    private static ManualResetEvent _acceptEvent = new ManualResetEvent(true);
    private static ManualResetEvent _readEvent = new ManualResetEvent(true);
    public static void Start()
    {
        //1. 创建Tcp Socket对象
        var serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        // serverSocket.Blocking = false;//设置为非阻塞
        var ipEndpoint = new IPEndPoint(IPAddress.Loopback, 5001);
        //2. 绑定Ip端口
        serverSocket.Bind(ipEndpoint);
        //3. 开启监听，指定最大连接数
        serverSocket.Listen(10);
        Console.WriteLine($&quot;服务端已启动({ipEndpoint})-等待连接...&quot;);

        while (true)
        {
            _acceptEvent.Reset();//重置信号量
            serverSocket.BeginAccept(OnClientConnected, serverSocket);
            _acceptEvent.WaitOne();//阻塞
        }
    }

    private static void OnClientConnected(IAsyncResult ar)
    {
        _acceptEvent.Set();//当有客户端连接进来后，则释放信号量
        var serverSocket = ar.AsyncState as Socket;
        Debug.Assert(serverSocket != null, nameof(serverSocket) + &quot; != null&quot;);

        var clientSocket = serverSocket.EndAccept(ar);
        Console.WriteLine($&quot;{clientSocket.RemoteEndPoint}-已连接&quot;);
        
        while (true)
        {
            _readEvent.Reset();//重置信号量
            var stateObj = new StateObject { ClientSocket = clientSocket };
            clientSocket.BeginReceive(stateObj.Buffer, 0, stateObj.Buffer.Length, SocketFlags.None, OnMessageReceived, stateObj);
            _readEvent.WaitOne();//阻塞等待
        }
    }

    private static void OnMessageReceived(IAsyncResult ar)
    {
        var state = ar.AsyncState as StateObject;
        Debug.Assert(state != null, nameof(state) + &quot; != null&quot;);
        var receiveLength = state.ClientSocket.EndReceive(ar);

        if (receiveLength &gt; 0)
        {
            var msg = Encoding.UTF8.GetString(state.Buffer, 0, receiveLength);
            Console.WriteLine($&quot;{state.ClientSocket.RemoteEndPoint}-接收数据：{msg}&quot;);

            var sendBuffer = Encoding.UTF8.GetBytes($&quot;received:{msg}&quot;);
            state.ClientSocket.BeginSend(sendBuffer, 0, sendBuffer.Length, SocketFlags.None,
                SendMessage, state.ClientSocket);
        }
    }

    private static void SendMessage(IAsyncResult ar)
    {
        var clientSocket = ar.AsyncState as Socket;
        Debug.Assert(clientSocket != null, nameof(clientSocket) + &quot; != null&quot;);
        clientSocket.EndSend(ar);
        _readEvent.Set(); //发送完毕后，释放信号量
    }
}

public class StateObject
{
    // Client  socket.  
    public Socket ClientSocket = null;
    // Size of receive buffer.  
    public const int BufferSize = 1024;
    // Receive buffer.  
    public byte[] Buffer = new byte[BufferSize];
}
</code></pre>
<p>首先来看运行结果，从下图可以看到，除了建立连接时CPU出现抖动外，在消息接收和发送阶段，CPU占有率趋于平缓，且占用率低。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2799767-bf36d3ea3c3ec980.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>分析代码后我们发现：</p>
<ol>
<li>CPU使用率是下来了，但代码复杂度上升了。</li>
<li>使用异步接口处理客户端连接：<code>BeginAccept</code>和<code>EndAccept</code></li>
<li>使用异步接口接收数据：<code>BeginReceive</code>和<code>EndReceive</code></li>
<li>使用异步接口发送数据：<code>BeginSend</code>和<code>EndSend</code></li>
<li>使用<code>ManualResetEvent</code>进行线程同步，避免线程空转</li>
</ol>
<p>那你可能好奇，以上模型是何种IO多路复用模型呢？<br>
好问题，我们来一探究竟。</p>
<h1 id="验证io模型">验证I/O模型</h1>
<p>要想验证应用使用的何种IO模型，只需要确定应用运行时发起了哪些系统调用即可。对于Linux系统来说，我们可以借助<code>strace</code>命令来跟踪指定应用发起的系统调用和信号。</p>
<h2 id="验证同步阻塞io发起的系统调用">验证同步阻塞I/O发起的系统调用</h2>
<p>可以使用VSCode Remote 连接到自己的Linux系统上，然后新建项目<code>Io.Demo</code>，以上面非阻塞IO的代码进行测试，执行以下启动跟踪命令：</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet$ ls
Io.Demo
shengjie@ubuntu:~/coding/dotnet$ strace -ff -o Io.Demo/strace/io dotnet run --project Io.Demo/
Press any key to start!
服务端已启动(127.0.0.1:5001)-等待连接...
127.0.0.1:36876-已连接
127.0.0.1:36876-开始接收数据...
127.0.0.1:36876-接收数据：1
</code></pre>
<p>另起命令行，执行<code>nc localhost 5001</code>模拟客户端连接。</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ nc localhost 5001
1
received:1
</code></pre>
<p>使用<code>netstat </code>命令查看建立的连接。</p>
<pre><code>shengjie@ubuntu:/proc/3763$ netstat -natp | grep 5001
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 127.0.0.1:5001          0.0.0.0:*               LISTEN      3763/Io.Demo        
tcp        0      0 127.0.0.1:36920         127.0.0.1:5001          ESTABLISHED 3798/nc             
tcp        0      0 127.0.0.1:5001          127.0.0.1:36920         ESTABLISHED 3763/Io.Demo 
</code></pre>
<p>另起命令行，执行<code> ps -h | grep dotnet</code>  抓取进程Id。</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ ps -h | grep dotnet
 3694 pts/1    S+     0:11 strace -ff -o Io.Demo/strace/io dotnet run --project Io.Demo/
 3696 pts/1    Sl+    0:01 dotnet run --project Io.Demo/
 3763 pts/1    Sl+    0:00 /home/shengjie/coding/dotnet/Io.Demo/bin/Debug/netcoreapp3.0/Io.Demo
 3779 pts/2    S+     0:00 grep --color=auto dotnet
shengjie@ubuntu:~/coding/dotnet$ ls Io.Demo/strace/ # 查看生成的系统调用文件
io.3696  io.3702  io.3708  io.3714  io.3720  io.3726  io.3732  io.3738  io.3744  io.3750  io.3766  io.3772  io.3782  io.3827
io.3697  io.3703  io.3709  io.3715  io.3721  io.3727  io.3733  io.3739  io.3745  io.3751  io.3767  io.3773  io.3786  io.3828
io.3698  io.3704  io.3710  io.3716  io.3722  io.3728  io.3734  io.3740  io.3746  io.3752  io.3768  io.3774  io.3787
io.3699  io.3705  io.3711  io.3717  io.3723  io.3729  io.3735  io.3741  io.3747  io.3763  io.3769  io.3777  io.3797
io.3700  io.3706  io.3712  io.3718  io.3724  io.3730  io.3736  io.3742  io.3748  io.3764  io.3770  io.3780  io.3799
io.3701  io.3707  io.3713  io.3719  io.3725  io.3731  io.3737  io.3743  io.3749  io.3765  io.3771  io.3781  io.3800
</code></pre>
<p>有上可知，进程Id为3763，依次执行以下命令可以查看该进程的线程和产生的文件描述符：</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ cd /proc/3763 # 进入进程目录
shengjie@ubuntu:/proc/3763$ ls
attr        cmdline          environ  io         mem         ns             pagemap      sched      smaps_rollup  syscall        wchan
autogroup   comm             exe      limits     mountinfo   numa_maps      patch_state  schedstat  stack         task
auxv        coredump_filter  fd       loginuid   mounts      oom_adj        personality  sessionid  stat          timers
cgroup      cpuset           fdinfo   map_files  mountstats  oom_score      projid_map   setgroups  statm         timerslack_ns
clear_refs  cwd              gid_map  maps       net         oom_score_adj  root         smaps      status        uid_map
shengjie@ubuntu:/proc/3763$ ll task # 查看当前进程启动的线程
total 0
dr-xr-xr-x 9 shengjie shengjie 0 5月  10 16:36 ./
dr-xr-xr-x 9 shengjie shengjie 0 5月  10 16:34 ../
dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3763/
dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3765/
dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3766/
dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3767/
dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3768/
dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3769/
dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3770/
shengjie@ubuntu:/proc/3763$ ll fd 查看当前进程系统调用产生的文件描述符
total 0
dr-x------ 2 shengjie shengjie  0 5月  10 16:36 ./
dr-xr-xr-x 9 shengjie shengjie  0 5月  10 16:34 ../
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 0 -&gt; /dev/pts/1
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 1 -&gt; /dev/pts/1
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 10 -&gt; 'socket:[44292]'
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 100 -&gt; /dev/random
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 11 -&gt; 'socket:[41675]'
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 13 -&gt; 'pipe:[45206]'
l-wx------ 1 shengjie shengjie 64 5月  10 16:37 14 -&gt; 'pipe:[45206]'
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 15 -&gt; /home/shengjie/coding/dotnet/Io.Demo/bin/Debug/netcoreapp3.0/Io.Demo.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 16 -&gt; /home/shengjie/coding/dotnet/Io.Demo/bin/Debug/netcoreapp3.0/Io.Demo.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 17 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Runtime.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 18 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Console.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 19 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Threading.dll
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 2 -&gt; /dev/pts/1
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 20 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Runtime.Extensions.dll
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 21 -&gt; /dev/pts/1
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 22 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Text.Encoding.Extensions.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 23 -&gt; /dev/urandom
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 24 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Net.Sockets.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 25 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Net.Primitives.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 26 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/Microsoft.Win32.Primitives.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 27 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Diagnostics.Tracing.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 28 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Threading.Tasks.dll
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 29 -&gt; 'socket:[43429]'
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 3 -&gt; 'pipe:[42148]'
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 30 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Threading.ThreadPool.dll
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 31 -&gt; 'socket:[42149]'
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 32 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Memory.dll
l-wx------ 1 shengjie shengjie 64 5月  10 16:37 4 -&gt; 'pipe:[42148]'
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 42 -&gt; /dev/urandom
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 5 -&gt; /dev/pts/1
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 6 -&gt; /dev/pts/1
lrwx------ 1 shengjie shengjie 64 5月  10 16:37 7 -&gt; /dev/pts/1
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 9 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Private.CoreLib.dll
lr-x------ 1 shengjie shengjie 64 5月  10 16:37 99 -&gt; /dev/urandom

</code></pre>
<p>从上面的输出来看，.NET Core控制台应用启动时启动了多个线程，并在10、11、29、31号文件描述符启动了socket监听。那哪一个文件描述符监听的是5001端口呢。</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ cat /proc/net/tcp | grep 1389 # 查看5001端口号相关的tcp链接（0x1389 为5001十六进制)
   4: 0100007F:1389 00000000:0000 0A 00000000:00000000 00:00000000 00000000  1000        0 43429 1 0000000000000000 100 0 0 10 0                     
  12: 0100007F:9038 0100007F:1389 01 00000000:00000000 00:00000000 00000000  1000        0 44343 1 0000000000000000 20 4 30 10 -1                    
  13: 0100007F:1389 0100007F:9038 01 00000000:00000000 00:00000000 00000000  1000        0 42149 1 0000000000000000 20 4 29 10 -1
</code></pre>
<p>从中可以看到inode为[43429]的socket监听在5001端口号，所以可以找到上面的输出行<code>lrwx------ 1 shengjie shengjie 64 5月  10 16:37 29 -&gt; 'socket:[43429]'</code>，进而判断监听5001端口号socket对应的文件描述符为29。</p>
<p>当然，也可以从记录到<code>strace</code>目录的日志文件找到线索。在文中我们已经提及，socket服务端编程的一般流程，都要经过socket-&gt;bind-&gt;accept-&gt;read-&gt;write流程。所以可以通过抓取关键字，查看相关系统调用。</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ grep 'bind' strace/ -rn
strace/io.3696:4570:bind(10, {sa_family=AF_UNIX, sun_path=&quot;/tmp/dotnet-diagnostic-3696-327175-socket&quot;}, 110) = 0
strace/io.3763:2241:bind(11, {sa_family=AF_UNIX, sun_path=&quot;/tmp/dotnet-diagnostic-3763-328365-socket&quot;}, 110) = 0
strace/io.3763:2949:bind(29, {sa_family=AF_INET, sin_port=htons(5001), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, 16) = 0
strace/io.3713:4634:bind(11, {sa_family=AF_UNIX, sun_path=&quot;/tmp/dotnet-diagnostic-3713-327405-socket&quot;}, 110) = 0
</code></pre>
<p>从上可知，在主线程也就是<code>io.3763</code>线程的系统调用文件中，将29号文件描述符与监听在<code>127.0.0.1:5001</code>的socket进行了绑定。同时也明白了.NET Core自动建立的另外2个socket是与diagnostic相关。<br>
接下来咱们重点看下3763号线程产生的系统调用。</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ cd strace/
shengjie@ubuntu:~/coding/dotnet/Io.Demo/strace$ cat io.3763 # 仅截取相关片段
socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP) = 29
setsockopt(29, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(29, {sa_family=AF_INET, sin_port=htons(5001), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, 16) = 0
listen(29, 10)       
write(21, &quot;\346\234\215\345\212\241\347\253\257\345\267\262\345\220\257\345\212\250(127.0.0.1:500&quot;..., 51) = 51
accept4(29, {sa_family=AF_INET, sin_port=htons(36920), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, [16], SOCK_CLOEXEC) = 31
write(21, &quot;127.0.0.1:36920-\345\267\262\350\277\236\346\216\245\n&quot;, 26) = 26
write(21, &quot;127.0.0.1:36920-\345\274\200\345\247\213\346\216\245\346\224\266\346\225\260\346&quot;..., 38) = 38
recvmsg(31, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base=&quot;1\n&quot;, iov_len=512}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 2
write(21, &quot;127.0.0.1:36920-\346\216\245\346\224\266\346\225\260\346\215\256\357\274\2321&quot;..., 34) = 34
sendmsg(31, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base=&quot;received:1\n&quot;, iov_len=11}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 11
accept4(29, 0x7fecf001c978, [16], SOCK_CLOEXEC) = ? ERESTARTSYS (To be restarted if SA_RESTART is set)
--- SIGWINCH {si_signo=SIGWINCH, si_code=SI_KERNEL} ---
</code></pre>
<p>从中我们可以发现几个关键的系统调用：</p>
<ol>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept4</li>
<li>recvmsg</li>
<li>sendmsg</li>
</ol>
<p>通过命令<code>man</code>命令可以查看下<code>accept4</code>和<code>recvmsg</code>系统调用的相关说明：</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo/strace$ man accept4
If no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a
       connection  is  present.

shengjie@ubuntu:~/coding/dotnet/Io.Demo/strace$ man recvmsg
If  no  messages are available at the socket, the receive calls wait for a message to arrive, unless the socket is nonblocking (see fcntl(2))
</code></pre>
<p>也就是说<code>accept4</code>和<code>recvmsg</code>是阻塞式系统调用。</p>
<h2 id="验证io多路复用发起的系统调用">验证I/O多路复用发起的系统调用</h2>
<p>同样以上面I/O多路复用的代码进行验证，验证步骤类似：</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet$ strace -ff -o Io.Demo/strace2/io dotnet run --project Io.Demo/
Press any key to start!
服务端已启动(127.0.0.1:5001)-等待连接...
127.0.0.1:37098-已连接
127.0.0.1:37098-接收数据：1

127.0.0.1:37098-接收数据：2

shengjie@ubuntu:~/coding/dotnet/Io.Demo$ nc localhost 5001
1
received:1
2
received:2

shengjie@ubuntu:/proc/2449$ netstat -natp | grep 5001
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 127.0.0.1:5001          0.0.0.0:*               LISTEN      2449/Io.Demo        
tcp        0      0 127.0.0.1:5001          127.0.0.1:56296         ESTABLISHED 2449/Io.Demo        
tcp        0      0 127.0.0.1:56296         127.0.0.1:5001          ESTABLISHED 2499/nc        

shengjie@ubuntu:~/coding/dotnet/Io.Demo$ ps -h | grep dotnet
 2400 pts/3    S+     0:10 strace -ff -o ./Io.Demo/strace2/io dotnet run --project Io.Demo/
 2402 pts/3    Sl+    0:01 dotnet run --project Io.Demo/
 2449 pts/3    Sl+    0:00 /home/shengjie/coding/dotnet/Io.Demo/bin/Debug/netcoreapp3.0/Io.Demo
 2516 pts/5    S+     0:00 grep --color=auto dotnet


shengjie@ubuntu:~/coding/dotnet/Io.Demo$ cd /proc/2449/
shengjie@ubuntu:/proc/2449$ ll task
total 0
dr-xr-xr-x 11 shengjie shengjie 0 5月  10 22:15 ./
dr-xr-xr-x  9 shengjie shengjie 0 5月  10 22:15 ../
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2449/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2451/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2452/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2453/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2454/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2455/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2456/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2459/
dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2462/
shengjie@ubuntu:/proc/2449$ ll fd
total 0
dr-x------ 2 shengjie shengjie  0 5月  10 22:15 ./
dr-xr-xr-x 9 shengjie shengjie  0 5月  10 22:15 ../
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 0 -&gt; /dev/pts/3
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 1 -&gt; /dev/pts/3
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 10 -&gt; 'socket:[35001]'
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 100 -&gt; /dev/random
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 11 -&gt; 'socket:[34304]'
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 13 -&gt; 'pipe:[31528]'
l-wx------ 1 shengjie shengjie 64 5月  10 22:16 14 -&gt; 'pipe:[31528]'
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 15 -&gt; /home/shengjie/coding/dotnet/Io.Demo/bin/Debug/netcoreapp3.0/Io.Demo.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 16 -&gt; /home/shengjie/coding/dotnet/Io.Demo/bin/Debug/netcoreapp3.0/Io.Demo.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 17 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Runtime.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 18 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Console.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 19 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Threading.dll
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 2 -&gt; /dev/pts/3
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 20 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Runtime.Extensions.dll
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 21 -&gt; /dev/pts/3
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 22 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Text.Encoding.Extensions.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 23 -&gt; /dev/urandom
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 24 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Net.Sockets.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 25 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Net.Primitives.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 26 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/Microsoft.Win32.Primitives.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 27 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Diagnostics.Tracing.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 28 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Threading.Tasks.dll
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 29 -&gt; 'socket:[31529]'
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 3 -&gt; 'pipe:[32055]'
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 30 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Threading.ThreadPool.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 31 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Collections.Concurrent.dll
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 32 -&gt; 'anon_inode:[eventpoll]'
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 33 -&gt; 'pipe:[32059]'
l-wx------ 1 shengjie shengjie 64 5月  10 22:16 34 -&gt; 'pipe:[32059]'
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 35 -&gt; 'socket:[35017]'
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 36 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Memory.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 37 -&gt; /dev/urandom
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 38 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Diagnostics.Debug.dll
l-wx------ 1 shengjie shengjie 64 5月  10 22:16 4 -&gt; 'pipe:[32055]'
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 5 -&gt; /dev/pts/3
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 6 -&gt; /dev/pts/3
lrwx------ 1 shengjie shengjie 64 5月  10 22:16 7 -&gt; /dev/pts/3
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 9 -&gt; /usr/share/dotnet/shared/Microsoft.NETCore.App/3.0.0/System.Private.CoreLib.dll
lr-x------ 1 shengjie shengjie 64 5月  10 22:16 99 -&gt; /dev/urandom
shengjie@ubuntu:/proc/2449$ cat /proc/net/tcp | grep 1389
   0: 0100007F:1389 00000000:0000 0A 00000000:00000000 00:00000000 00000000  1000        0 31529 1 0000000000000000 100 0 0 10 0                     
   8: 0100007F:1389 0100007F:DBE8 01 00000000:00000000 00:00000000 00000000  1000        0 35017 1 0000000000000000 20 4 29 10 -1                    
  12: 0100007F:DBE8 0100007F:1389 01 00000000:00000000 00:00000000 00000000  1000        0 28496 1 0000000000000000 20 4 30 10 -1  
</code></pre>
<p>过滤<code>strace2</code> 目录日志，抓取监听在<code>localhost:5001</code>socket对应的文件描述符。</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ grep 'bind' strace2/ -rn
strace2/io.2449:2243:bind(11, {sa_family=AF_UNIX, sun_path=&quot;/tmp/dotnet-diagnostic-2449-23147-socket&quot;}, 110) = 0
strace2/io.2449:2950:bind(29, {sa_family=AF_INET, sin_port=htons(5001), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, 16) = 0
strace2/io.2365:4568:bind(10, {sa_family=AF_UNIX, sun_path=&quot;/tmp/dotnet-diagnostic-2365-19043-socket&quot;}, 110) = 0
strace2/io.2420:4634:bind(11, {sa_family=AF_UNIX, sun_path=&quot;/tmp/dotnet-diagnostic-2420-22262-socket&quot;}, 110) = 0
strace2/io.2402:4569:bind(10, {sa_family=AF_UNIX, sun_path=&quot;/tmp/dotnet-diagnostic-2402-22042-socket&quot;}, 110) = 0
</code></pre>
<p>从中可以看出同样是29号文件描述符，相关系统调用记录中<code>io.2449</code>文件中，打开文件，可以发现相关系统调用如下：</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ cat strace2/io.2449 # 截取相关系统调用
socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP) = 29
setsockopt(29, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(29, {sa_family=AF_INET, sin_port=htons(5001), sin_addr=inet_addr(&quot;127.0.0.1&quot;)}, 16) = 0
listen(29, 10) 
accept4(29, 0x7fa16c01b9e8, [16], SOCK_CLOEXEC) = -1 EAGAIN (Resource temporarily unavailable)
epoll_create1(EPOLL_CLOEXEC)            = 32
epoll_ctl(32, EPOLL_CTL_ADD, 29, {EPOLLIN|EPOLLOUT|EPOLLET, {u32=0, u64=0}}) = 0
accept4(29, 0x7fa16c01cd60, [16], SOCK_CLOEXEC) = -1 EAGAIN (Resource temporarily unavailable)
</code></pre>
<p>从中我们可以发现<code>accept4</code>直接返回-1而不阻塞，监听在<code>127.0.0.1:5001</code>的socket对应的29号文件描述符最终作为<code>epoll_ctl</code>的参数关联到<code>epoll_create1</code>创建的32号文件描述符上。最终32号文件描述符会被<code>epoll_wait</code>阻塞，以等待连接请求。我们可以抓取<code>epoll</code>相关的系统调用来验证：</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo$ grep 'epoll' strace2/ -rn
strace2/io.2459:364:epoll_ctl(32, EPOLL_CTL_ADD, 35, {EPOLLIN|EPOLLOUT|EPOLLET, {u32=1, u64=1}}) = 0
strace2/io.2462:21:epoll_wait(32, [{EPOLLIN, {u32=0, u64=0}}], 1024, -1) = 1
strace2/io.2462:42:epoll_wait(32, [{EPOLLOUT, {u32=1, u64=1}}], 1024, -1) = 1
strace2/io.2462:43:epoll_wait(32, [{EPOLLIN|EPOLLOUT, {u32=1, u64=1}}], 1024, -1) = 1
strace2/io.2462:53:epoll_wait(32, 
strace2/io.2449:3033:epoll_create1(EPOLL_CLOEXEC)            = 32
strace2/io.2449:3035:epoll_ctl(32, EPOLL_CTL_ADD, 33, {EPOLLIN|EPOLLET, {u32=4294967295, u64=18446744073709551615}}) = 0
strace2/io.2449:3061:epoll_ctl(32, EPOLL_CTL_ADD, 29, {EPOLLIN|EPOLLOUT|EPOLLET, {u32=0, u64=0}}) = 0
</code></pre>
<p>因此我们可以断定同步非阻塞I/O的示例使用的时IO多路复用的epoll模型。</p>
<p>关于epoll相关命令，man命令可以查看下<code>epoll_create1</code>、<code>epoll_ctl</code>和、<code>epoll_wait</code>系统调用的相关说明：</p>
<pre><code>shengjie@ubuntu:~/coding/dotnet/Io.Demo/strace$ man epoll_create
DESCRIPTION
       epoll_create() creates a new epoll(7) instance.  Since Linux 2.6.8, the size argument is ignored, but must be
       greater than zero; see NOTES below.

       epoll_create() returns a file descriptor referring to the new epoll instance.  This file descriptor  is  used
       for  all  the subsequent calls to the epoll interface.

shengjie@ubuntu:~/coding/dotnet/Io.Demo/strace$ man epoll_ctl
DESCRIPTION
       This  system  call  performs  control  operations on the epoll(7) instance referred to by the file descriptor
       epfd.  It requests that the operation op be performed for the target file descriptor, fd.

       Valid values for the op argument are:

       EPOLL_CTL_ADD
              Register the target file descriptor fd on the epoll instance referred to by the file  descriptor  epfd
              and associate the event event with the internal file linked to fd.

       EPOLL_CTL_MOD
              Change the event event associated with the target file descriptor fd.

       EPOLL_CTL_DEL
              Remove  (deregister)  the  target file descriptor fd from the epoll instance referred to by epfd.  The
              event is ignored and can be NULL (but see BUGS below).

shengjie@ubuntu:~/coding/dotnet/Io.Demo/strace$ man epoll_wait
DESCRIPTION
       The  epoll_wait()  system  call  waits for events on the epoll(7) instance referred to by the file descriptor
       epfd.  The memory area pointed to by events will contain the events that will be available  for  the  caller.
       Up to maxevents are returned by epoll_wait().  The maxevents argument must be greater than zero.

       The  timeout  argument  specifies  the number of milliseconds that epoll_wait() will block.  Time is measured
       against the CLOCK_MONOTONIC clock.  The call will block until either:

       *  a file descriptor delivers an event;

       *  the call is interrupted by a signal handler; or

       *  the timeout expires.
</code></pre>
<p>简而言之，epoll通过创建一个新的文件描述符来替换旧的文件描述符来完成阻塞工作，当有事件或超时时通知原有文件描述符进行处理，以实现非阻塞的线程模型。</p>
<h1 id="总结">总结</h1>
<p>写完这篇文章，对I/O模型的理解有所加深，但由于对Linux系统的了解不深，所以难免有纰漏之处，大家多多指教。<br>
同时也不仅感叹Linux的强大之处，一切皆文件的设计思想，让一切都有迹可循。现在.NET 已经完全实现跨平台了，那么Linux操作系统大家就有必要熟悉起来了。</p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-05-12 08:55</span>&nbsp;
<a href="https://www.cnblogs.com/sheng-jie/">「圣杰」</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12871416" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12871416);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 326932, cb_blogApp = 'sheng-jie', cb_blogUserGuid = '56782349-8e3d-e311-8d02-90b11c0b17d6';
    var cb_entryId = 12871416, cb_entryCreatedDate = '2020-05-12 08:55', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 「圣杰」
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <script src="https://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<link href="https://files.cnblogs.com/files/sheng-jie/auto.catalogs.css" rel="stylesheet">
<script type="text/javascript" src="https://files.cnblogs.com/files/sheng-jie/auto.catalogs.js"></script>
<script>
//Setting ico for cnblogs
var linkObject = document.createElement('link');
linkObject.rel = "shortcut icon";
linkObject.href = "https://files.cnblogs.com/files/sheng-jie/brand.ico";
document.getElementsByTagName("head")[0].appendChild(linkObject);

window.tctipConfig = {
        imagePrefix: "https://files.cnblogs.com/files/kdy11/",
        cssPrefix:     "https://files.cnblogs.com/files/kdy11",
        buttonImageId:  4,
        buttonTip:  "dashang",
        list:{
            alipay: {qrimg: "https://files.cnblogs.com/files/sheng-jie/zfb.bmp"},
            weixin:{qrimg: "https://files.cnblogs.com/files/sheng-jie/wechat.bmp"},
        }
};
</script>
<script src="https://files.cnblogs.com/files/kdy11/tctip.min.js"></script>
<script type="text/javascript">
$(function() {
	// hide #back-top first
	$("#back-top").hide();
	// fade in #back-top
	$(window).scroll(function() {
		if ($(this).scrollTop() > 500) {
			$('#back-top').fadeIn();
		} else {
			$('#back-top').fadeOut();
		}
	});
	// scroll body to 0px on click
	$('#back-top a').click(function() {
		$('body,html').animate({
			scrollTop: 0
		}, 800);
		return false;
	});

       $('#div_digg').append('<a href="#tbCommentAuthor" id="quickReply">快速评论</a>')
});
</script>
    </div>
</body>
</html>